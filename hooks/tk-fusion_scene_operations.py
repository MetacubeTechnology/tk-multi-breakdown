# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import PeyeonScript
from tank import Hook
from tank import TankError

class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for Nuke.

    This implementation handles detection of Nuke read nodes,
    geometry nodes and camera nodes.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        f_connection = PeyeonScript.scriptapp ("Fusion")
        the_comp = f_connection.GetCurrentComp ()

        self.parent.log_debug("Current Comp: %s" % the_comp)

        # Here we save the file so we can read the most updated data from the loaders
        file_path = the_comp.GetAttrs ('COMPS_FileName')
        the_comp.Save (file_path)

        # first let's look at the loaders
        # we start adding their names to a list, so we can use it later to find
        # their paths in the composition file
        loader_list = []
        for index, node in the_comp.GetToolList (False, "Loader").iteritems ():
            node_name = node.Name
            loader_list.append (node_name)

        # We use this function to get a dict list with the loaders and their content
        # Values in order are: [list of loader names], "path to composition", "Type of node"
        reads = self.get_loader_filename_from_comp (loader_list, file_path, "Read")

        self.parent.log_debug("Finding the follwing loaders: %s" % reads)

        # UNLESS THERE ARE OTHER KIND OF LOADERS OR THINGS TO CARE ABOUT, THIS IS UNNECESSARY
        # HOWEVER I LEAVE THIS HERE AS REFERENCE IN CASE IT IS INDEED NEEDED
        '''
        # then the read geometry nodes    
        for node in nuke.allNodes("ReadGeo2"):
            node_name = node.name()
            
            path = node.knob('file').value().replace("/", os.path.sep)
            reads.append( {"node": node_name, "type": "ReadGeo2", "path": path})
        
        # then the read camera nodes    
        for node in nuke.allNodes("Camera2"):
            node_name = node.name()
            
            path = node.knob('file').value().replace("/", os.path.sep)
            reads.append( {"node": node_name, "type": "Camera2", "path": path})
        '''

        return reads


    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """

        f_connection = PeyeonScript.scriptapp ("Fusion")
        the_comp = f_connection.GetCurrentComp ()

        engine = self.parent.engine

        list_of_loaders = {}
        for index, value in the_comp.GetToolList (False, "Loader").iteritems ():
            list_of_loaders[value.Name] = value


        #node_type_list = ["Read", "ReadGeo2", "Camera2"]
        node_type_list = ["Read"]
        for i in items:
            node_name = i["node"]
            node_type = i["type"]
            new_path = i["path"]

            if node_type in node_type_list :
                engine.log_debug("Node %s: Updating to version %s" % (node_name, new_path))
                
                node = list_of_loaders[node_name]
                # make sure slashes are handled correctly - always forward
                new_path = new_path.replace(os.path.sep, "/")
                node.Clip = new_path


    def get_loader_filename_from_comp (self, loaders, comp_path, the_type):
        loader_list = []
        try:
            for a in loaders:
                loader_list.append ({'node': a, 'type': the_type})

            total_to_find = len (loaders)
            total_found = 0

            check_comp = open (comp_path, "r")
            looking = False
            selected = 0
            for a in check_comp:
                if total_found >= total_to_find:
                    break
                counter = 0
                if not looking:
                    for b in loaders:
                        if b in a:
                            looking = True
                            selected = counter
                            break
                        counter += 1
                else:
                    if 'Filename = ' in a:
                        total_found += 1
                        added_line = a.split ('"')[1]
                        loader_list[selected]['path'] = added_line
                        looking = False
        except:
            import traceback
            error = traceback.format_exec()
            raise TankError("Failed trying to read loader from comp source file: \n%s" % error)

        return loader_list